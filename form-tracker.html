<link rel="import" href="../polymer/polymer-element.html">

<script>
  (() => {

    const objectType = {
      [Array]: 'array',
      [Object]: 'object',
      [String]: 'string',
      [Number]: 'number',
      [Function]: 'function'
    };

    const clone = (a) => {
      if (Array.isArray(a)) {
        return a.map(i => clone(i));
      } else {
        if (typeof a === 'object') {
          if (a.constructor.name !== 'Date') {
            return Object.assign({}, Object.keys(a).reduce((p, i) => {
              p[i] = clone(a[i]);
              return p;
            }, {}));
          } else {
            return new Date(a.getTime());
          }
        } else {
          return a;
        }
      }
    };

    const isArray = (prop) => {
      return (prop.type || prop) === Array;
    };
    const isArrayOrObject = (prop) => {
      const propType = (prop.type || prop);
      return propType === Object || propType === Array;
    };

    const checkType = (prop) => {
      const propType = (prop.type || prop);
      return objectType[propType];
    };

    const bind = (element, properties) => {
      var bindings = Object.keys(properties).filter((name) => {
        const property = properties[name];
        if (Object.prototype.hasOwnProperty.call(property, 'trackChange')) {
          return true;
        }
        return false;
      });
      return bindings;
    };

    let formTrackers = {};
    window.formTrackers = formTrackers;

    window.FormTrackerMixin = (superClass) => class extends superClass {
      constructor() {
        super();
        window.aaa = this;
        this.key = Symbol();
        formTrackers[this.key] = {
          isEnable: false,
          props: [],
          paths: {},
          children: new Map()
        };
        this.addEventListener('form-tracker-child-register', e => this._onChildElementRegistered(e));
        this.addEventListener('form-tracker-changed', e => this._onChildElementChanged(e));
      }

      connectedCallback() {
        this.setupObserver();
        super.connectedCallback();
        const event = new CustomEvent('form-tracker-child-register', {
          bubbles: true,
          composed: true,
          detail: {elem: this}
        });
        this.dispatchEvent(event);
      }

      disconnectedCallback() {
        //unbind(this);
        super.disconnectedCallback();
      }

      setupObserver() {
        const opt = formTrackers[this.key];
        //const {properties, trackers} = this.constructor;
        const {properties} = this.constructor;
        opt.props = bind(this, properties);

        opt.props.forEach(i => {
          const propType = checkType(properties[i]);
          const isEqualFn= properties[i].isEqualFn;
          let observerName = '_observeFormTrackerDefaultMixin';
          if (propType === 'array') {
            observerName = '_observeFormTrackerArrayMixin';
          }
          this._createMethodObserver(`${observerName}('${i}', ${i}.*, '${isEqualFn}')`, true);
        });

        /*if (trackers) {
          Object.keys(trackers).forEach(i => {
            if (opt.props.indexOf(i) < 0) {opt.props.push(i);}
            const {observePath, isEqual} = trackers[i];
            const propType = checkType(properties[i]);
            let observerName = '_observeFormTrackerDefaultMixin';
            if (propType === 'array') {
              observerName = '_observeFormTrackerArrayMixin';
            }
            this._createMethodObserver(`${observerName}('${i}', ${observePath}, '${isEqual}')`, true);
          });
        }*/
      }

      static get properties() {
        return {
          isEnable: {type: Boolean, value: false}
        };
      }

      _onChildElementRegistered(e) {
        const {elem} = e.detail;
        if (elem !== this) {
          const {children} = formTrackers[this.key];
          children.set(elem, undefined);
        }
      }

      _onChildElementChanged(e) {
        const {elem, hasChanged} = e.detail;
        if (elem !== this) {
          const {children} = formTrackers[this.key];
          children.set(elem, hasChanged);
          const anyChildHasChanged = Array.from(children.values()).some(i => i === true);
          this.hasChanged = anyChildHasChanged;
        }
      }

      _getOriginalData() {
        return formTrackers[this.key].originalData;
      }

      _enableTracking() {
        let opt = formTrackers[this.key];
        this.isEnable = true;
        this._toggleTrackingFlagForChildren(true);
        opt.originalData = opt.props.reduce((p, i) => {
          p[i] = clone(this[i]);
          return p;
        }, {});
      }

      _toggleTrackingFlagForChildren(flag) {
        const {children} = formTrackers[this.key];
        const elems = Array.from(children.keys());
        if (flag) {
          elems.forEach(c => c._enableTracking());
        } else {
          elems.forEach(c => c._disableTracking());
        }
      }

      _disableTracking() {
        this.isEnable = false;
        this._toggleTrackingFlagForChildren(false);
      }

      _isEqual(a, b) {
        return a === b;
      }

      _compareValue(isEqualFn, a, b) {
        const fn = (isEqualFn && this[isEqualFn]) ? this[isEqualFn] : this._isEqual;
        return fn(a,b);
      }

      _observeFormTrackerDefaultMixin(prop, newValue, isEqualFn) {
        if (newValue) {
          const {path, value, base} = newValue;
          const opt = formTrackers[this.key];
          if (this.isEnable) {
            console.log(path, value);

            const orgValue = Polymer.Base.get(path, opt.originalData);
            const isEqual = this._compareValue(isEqualFn, orgValue, value);

            if (!isEqual) {
              opt.paths[path] = value;
            } else {
              delete opt.paths[path];
            }

            const hasChanged = Object.keys(opt.paths).length > 0;

            if (this.hasChanged !== hasChanged) {
              this.hasChanged = hasChanged;
              this._invalidateProperties();

              const event = new CustomEvent('form-tracker-changed', {
                bubbles: true,
                composed: true,
                detail: {path, value, hasChanged, elem: this}
              });
              this.dispatchEvent(event);
            }
          }
        }
      }

      _observeFormTrackerArrayMixin(prop, newValue, isEqualFn) {
        /*var {path, value, base} = newValue;
         console.log('---------------');
         console.log(path, value.indexSplices ? value.indexSplices[0] : '---', base);
         return;*/
        if (newValue) {
          if (this.isEnable) {
            const {path: actionPath, value, base} = newValue;
            let temp =  actionPath.split('.');
            const arrayChangedMethod = temp.pop();
            const path = temp.join('.');
            let changedInfo = {};
            if (arrayChangedMethod !== 'length') {
              if (arrayChangedMethod === 'splices') {
                changedInfo = value.indexSplices[0];
              } else {
                changedInfo = {index: arrayChangedMethod, updated: value};
              }
              const opt = formTrackers[this.key];
              const orgValue = Polymer.Base.get(prop, opt.originalData);
              const currentValue = Polymer.Base.get(prop, this);

              const isEqual = this._compareValue(isEqualFn, orgValue, currentValue);

              if (!isEqual) {
                opt.paths[path] = value;
              } else {
                delete opt.paths[path];
              }


              /*if (isEqualFn && this[isEqualFn]) {
                const isEqual = this[isEqualFn](orgValue, currentValue);
                if (!isEqual) {
                  opt.paths[prop] = changedInfo;
                } else {
                  delete opt.paths[prop];
                }
              } else {
                if (orgValue !== currentValue) {
                  opt.paths[prop] = changedInfo;
                } else {
                  delete opt.paths[prop];
                }
              }*/

              const hasChanged = Object.keys(opt.paths).length > 0;

              if (this.hasChanged !== hasChanged) {
                this.hasChanged = hasChanged;
                this._invalidateProperties();

                const event = new CustomEvent('form-tracker-changed', {
                  bubbles: true,
                  composed: true,
                  detail: {
                    path,
                    hasChanged,
                    value: changedInfo,
                    elem: this,
                  }
                });
                this.dispatchEvent(event);
              }
            }
          }
        }
      }

      _getTrackingStatus(isEnable) {
        return this.isEnable === true ? 'On' : 'Off';
      }


    };
  })();
</script>


<dom-module id="form-tracker">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <h2>Hello [[prop1]]!</h2>
  </template>

  <script>
    /**
     * `form-tracker`
     *
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class FormTracker extends Polymer.Element {
      static get is() { return 'form-tracker'; }

      static get properties() {
        return {
          prop1: {
            type: String,
            value: 'form-tracker'
          }
        };
      }
    }

    window.customElements.define(FormTracker.is, FormTracker);
  </script>
</dom-module>
